import { Elysia, t } from 'elysia';
import { Feed } from 'feed';
import MarkdownIt from 'markdown-it';
import { randomUUID } from 'crypto';
import { mkdir } from 'fs/promises';
import { join } from 'path';
import { networkInterfaces } from 'os';

// ç¯å¢ƒå˜é‡é…ç½®
const PORT = process.env.PORT || 8765;
const AUTH_TOKEN = process.env.AUTH_TOKEN || '';
const FEED_TITLE = process.env.FEED_TITLE || 'AI Briefing';
const FEED_DESCRIPTION = process.env.FEED_DESCRIPTION || 'Daily news summaries generated by AI.';
const FEED_URL = process.env.FEED_URL || `http://localhost:${PORT}`;

// æ•°æ®æ–‡ä»¶è·¯å¾„
const DATA_DIR = join(process.cwd(), 'data');
const POSTS_FILE = join(DATA_DIR, 'posts.json');

// Markdown è§£æå™¨
const md = new MarkdownIt();

// æ•°æ®æ¨¡å‹
interface Post {
  id: string;
  title: string;
  link: string;
  content: string;
  contentMarkdown: string;
  summary: string;
  tags?: string[];
  author?: string;
  pubDate: Date;
}

// å·¥å…·å‡½æ•°

/**
 * ç¡®ä¿ data ç›®å½•å­˜åœ¨
 */
async function ensureDataDir(): Promise<void> {
  try {
    await mkdir(DATA_DIR, { recursive: true });
  } catch (error) {
    console.error('Failed to create data directory:', error);
  }
}

/**
 * è¯»å– posts æ•°æ®
 */
async function readPosts(): Promise<Post[]> {
  try {
    const file = Bun.file(POSTS_FILE);
    const exists = await file.exists();

    if (!exists) {
      return [];
    }

    const data = await file.json();
    // å°†æ—¥æœŸå­—ç¬¦ä¸²è½¬æ¢å› Date å¯¹è±¡
    return data.map((post: any) => ({
      ...post,
      pubDate: new Date(post.pubDate)
    }));
  } catch (error) {
    console.error('Failed to read posts:', error);
    return [];
  }
}

/**
 * å†™å…¥ posts æ•°æ®
 */
async function writePosts(posts: Post[]): Promise<void> {
  await ensureDataDir();
  await Bun.write(POSTS_FILE, JSON.stringify(posts, null, 2));
}

/**
 * ç”Ÿæˆ UUID
 */
function generateId(): string {
  return randomUUID();
}

/**
 * Markdown è½¬ HTML
 */
function markdownToHtml(markdown: string): string {
  return md.render(markdown);
}

/**
 * ç”Ÿæˆçº¯æ–‡æœ¬æ‘˜è¦
 */
function generateSummary(html: string, maxLength: number = 150): string {
  // å»é™¤ HTML æ ‡ç­¾
  const text = html.replace(/<[^>]*>/g, '');
  // å»é™¤å¤šä½™ç©ºç™½
  const cleaned = text.replace(/\s+/g, ' ').trim();
  // æˆªå–æŒ‡å®šé•¿åº¦
  if (cleaned.length <= maxLength) {
    return cleaned;
  }
  return cleaned.substring(0, maxLength) + '...';
}

// åˆ›å»º Elysia åº”ç”¨
const app = new Elysia()
  .get('/', () => ({
    message: 'Agent2RSS Service',
    version: '1.0.0',
    endpoints: {
      webhook: 'POST /api/webhook',
      rss: 'GET /rss.xml'
    }
  }))

  // POST /api/webhook - æ¥æ”¶ AI Agent å‘é€çš„å†…å®¹
  .post('/api/webhook', async ({ body, headers, set }) => {
    try {
      // é‰´æƒæ£€æŸ¥
      const authToken = headers['x-auth-token'];
      if (!authToken || authToken !== AUTH_TOKEN) {
        set.status = 401;
        return { error: 'Unauthorized' };
      }

      // è½¬æ¢ Markdown ä¸º HTML
      const html = markdownToHtml(body.content);

      // ç”Ÿæˆæ‘˜è¦
      const summary = generateSummary(html);

      // åˆ›å»ºæ–° Post
      const newPost: Post = {
        id: generateId(),
        title: body.title,
        link: body.link,
        content: html,
        contentMarkdown: body.content,
        summary,
        tags: body.tags,
        author: body.author,
        pubDate: new Date()
      };

      // è¯»å–ç°æœ‰ posts
      const posts = await readPosts();

      // æ·»åŠ æ–° post åˆ°å¼€å¤´ï¼Œä¿ç•™æœ€æ–° 100 æ¡
      const updatedPosts = [newPost, ...posts].slice(0, 100);

      // å†™å›æ–‡ä»¶
      await writePosts(updatedPosts);

      return {
        success: true,
        message: 'Post added successfully',
        post: {
          id: newPost.id,
          title: newPost.title,
          pubDate: newPost.pubDate
        }
      };
    } catch (error) {
      console.error('Error processing webhook:', error);
      set.status = 500;
      return { error: 'Internal server error' };
    }
  }, {
    body: t.Object({
      title: t.String(),
      link: t.String(),
      content: t.String(),
      tags: t.Optional(t.Array(t.String())),
      author: t.Optional(t.String())
    })
  })

  // GET /rss.xml - ç”Ÿæˆ RSS feed
  .get('/rss.xml', async ({ set }) => {
    try {
      // è¯»å– posts
      const posts = await readPosts();

      // åˆ›å»º Feed å®ä¾‹
      const feed = new Feed({
        title: FEED_TITLE,
        description: FEED_DESCRIPTION,
        id: FEED_URL,
        link: FEED_URL,
        language: 'zh-CN',
        feedLinks: {
          rss: `${FEED_URL}/rss.xml`
        },
        copyright: `All rights reserved ${new Date().getFullYear()}`,
        updated: posts.length > 0 ? posts[0].pubDate : new Date()
      });

      // æ·»åŠ æ¯ä¸ª post åˆ° feed
      for (const post of posts) {
        feed.addItem({
          title: post.title,
          id: post.link,
          link: post.link,
          description: post.summary,
          content: post.content,
          date: post.pubDate,
          author: post.author ? [{ name: post.author }] : undefined,
          category: post.tags?.map(tag => ({ name: tag }))
        });
      }

      // ç”Ÿæˆ RSS 2.0 XML
      const rssXml = feed.rss2();

      // è®¾ç½®å“åº”å¤´
      set.headers['Content-Type'] = 'application/xml; charset=utf-8';

      return rssXml;
    } catch (error) {
      console.error('Error generating RSS:', error);
      set.status = 500;
      return { error: 'Failed to generate RSS feed' };
    }
  })

  .listen(Number(PORT));

// è·å–æœ¬æœºå±€åŸŸç½‘ IP
function getLocalIP(): string | null {
  const nets = networkInterfaces();
  for (const name of Object.keys(nets)) {
    const netInfo = nets[name];
    if (!netInfo) continue;
    for (const net of netInfo) {
      // è·³è¿‡å†…éƒ¨åœ°å€å’Œé IPv4 åœ°å€
      if (net.family === 'IPv4' && !net.internal) {
        return net.address;
      }
    }
  }
  return null;
}

const localIP = getLocalIP();

console.log(`ğŸš€ Agent2RSS is running on port ${PORT}`);
console.log(`\nğŸ“° RSS Feed URLs:`);
console.log(`   Local:  http://localhost:${PORT}/rss.xml`);
if (localIP) {
  console.log(`   LAN:    http://${localIP}:${PORT}/rss.xml`);
}
console.log(`\nğŸ“¡ Webhook endpoint:`);
console.log(`   POST http://localhost:${PORT}/api/webhook`);
